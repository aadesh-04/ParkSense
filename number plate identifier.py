# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pzmprr33kFdvkreFJPDeDdMv3E-chelm
"""

!pip install easyocr

!sudo apt install tesseract-ocr-eng

import pytesseract

# Set the path to the tesseract executable (replace with your actual path)
pytesseract.pytesseract.tesseract_cmd = r'/usr/bin/tesseract'

!pip install pytesseract

!pip install opencv-python-headless

"""Best code until now"""

import cv2
from PIL import Image, ImageEnhance, ImageFilter
import pytesseract
import re
import easyocr

def detect_and_recognize_plate(image_path, cascade_path='haarcascade_russian_plate_number.xml'):
    # Step 1: Attempt Primary Code (Haar Cascade + Tesseract OCR)
    primary_result = process_using_primary_method(image_path, cascade_path)

    # Step 2: If Primary Code fails or gives invalid result, use EasyOCR as fallback
    if primary_result == "License plate not detected!" or not is_valid_format(primary_result):
        print("Primary method failed or gave invalid result, switching to EasyOCR...")
        secondary_result = process_using_secondary_method(image_path)

        # Compare the primary and secondary results
        final_result = choose_best_result(primary_result, secondary_result)
    else:
        final_result = primary_result  # Return primary result if valid

    return final_result

def process_using_primary_method(image_path, cascade_path):
    # Step 1: Load the image
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Step 2: Load Haar Cascade for license plate detection
    plate_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + cascade_path)

    # Detect plates
    plates = plate_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(50, 50))

    if len(plates) == 0:
        return "License plate not detected!"

    # Crop the first detected plate
    for (x, y, w, h) in plates:
        license_plate = image[y:y + h, x:x + w]
        break

    # Step 3: Preprocess the license plate for OCR
    license_plate_gray = cv2.cvtColor(license_plate, cv2.COLOR_BGR2GRAY)
    license_plate_gray = cv2.resize(license_plate_gray, (0, 0), fx=2, fy=2)  # Resize to enhance details
    _, license_plate_binary = cv2.threshold(license_plate_gray, 120, 255, cv2.THRESH_BINARY)

    # Save the cropped plate (optional for debugging)
    cv2.imwrite('cropped_license_plate.jpg', license_plate_binary)

    # Step 4: OCR for text extraction using Tesseract
    plate_image = Image.fromarray(license_plate_binary)
    plate_image = plate_image.filter(ImageFilter.SHARPEN)
    enhancer = ImageEnhance.Contrast(plate_image)
    plate_image = enhancer.enhance(2)

    custom_config = r'--psm 7 -c tessedit_char_whitelist=ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    extracted_text = pytesseract.image_to_string(plate_image, config=custom_config)

    # Step 5: Format validation and automatic correction
    corrected_text = auto_correct_license_plate(extracted_text)

    # Step 6: Ensure output matches the exact format (4 letters + 6 numbers)
    corrected_text = ensure_strict_format(corrected_text)

    return corrected_text.strip()

def process_using_secondary_method(image_path):
    # Initialize EasyOCR reader
    reader = easyocr.Reader(['en'])

    # Extract text using EasyOCR
    result = reader.readtext(image_path, detail=0)

    # Join the extracted text
    extracted_text = ' '.join(result).replace(" ", "").upper()

    # Step 5: Format validation and automatic correction
    corrected_text = auto_correct_license_plate(extracted_text)

    # Step 6: Ensure output matches the exact format (4 letters + 6 numbers)
    corrected_text = ensure_strict_format(corrected_text)

    return corrected_text.strip()

def auto_correct_license_plate(text):
    # Remove any extra spaces and ensure text is in uppercase
    text = text.replace(" ", "").upper()

    # Define common OCR misinterpretation patterns
    corrections = {
        "O": "0",  # 'O' might be mistaken for '0'
        "I": "1",  # 'I', might be mistaken for '1'
        "L": "1",  # 'L' might be mistaken for '1'
        "Z": "2",  # 'Z' might be mistaken for '2'
        "S": "5",  # 'S' might be mistaken for '5'
        "B": "8",  # 'B' might be mistaken for '8'
        "G": "6",  # 'G' might be mistaken for '6'
        "Q": "0",  # 'Q' might be mistaken for '0'
        "A": "4",  # 'A' might be mistaken for '4'
        "E": "3",  # 'E' might be mistaken for '3'
        "T": "7",  # 'T' might be mistaken for '7'
        "D": "0",  # 'D' might be mistaken for '0'

    }

    # Apply corrections to the extracted text
    corrected_text = ''.join([corrections.get(c, c) for c in text])  # Replace based on mapping

    return corrected_text

def ensure_strict_format(text):
    # Ensure the format strictly follows 4 letters and 6 numbers (Total 10 characters)
    # Format: 2 letters + 2 numbers + 2 letters + 4 numbers
    letters = ''.join([ch for ch in text if ch.isalpha()])
    numbers = ''.join([ch for ch in text if ch.isdigit()])

    # Enforce exactly 4 letters and 6 numbers
    if len(letters) < 4:
        letters = letters.ljust(4, 'A')  # Fill with 'A' if less than 4 letters
    if len(numbers) < 6:
        numbers = numbers.ljust(6, '0')  # Fill with '0' if less than 6 numbers

    # Ensure the text fits the format: 2 letters + 2 numbers + 2 letters + 4 numbers
    formatted_text = letters[:2] + numbers[:2] + letters[2:4] + numbers[2:6]

    # Recheck if it matches the exact 4 letters and 6 numbers format
    if len(formatted_text) != 10 or not re.match(r"^[A-Z]{2}[0-9]{2}[A-Z]{2}[0-9]{4}$", formatted_text):
        # If it's still incorrect, try to fix it by ensuring strict sequence
        formatted_text = formatted_text[:10]  # Limit to 10 characters strictly

    return formatted_text

def is_valid_format(text):
    # Check if the text matches the valid format: 4 letters and 6 numbers
    return bool(re.match(r"^[A-Z]{2}[0-9]{2}[A-Z]{2}[0-9]{4}$", text))

def choose_best_result(primary_result, secondary_result):
    # Compare the primary and secondary results and choose the best one
    if primary_result == "License plate not detected!" or not is_valid_format(primary_result):
        return secondary_result  # Return secondary result if primary failed

    if secondary_result == "License plate not detected!" or not is_valid_format(secondary_result):
        return primary_result  # Return primary result if secondary failed

    # If both are valid, choose the most relevant one by comparing similarity
    # We will prefer the result that is more similar in terms of letters and numbers.

    primary_letters = ''.join([ch for ch in primary_result if ch.isalpha()])
    primary_numbers = ''.join([ch for ch in primary_result if ch.isdigit()])

    secondary_letters = ''.join([ch for ch in secondary_result if ch.isalpha()])
    secondary_numbers = ''.join([ch for ch in secondary_result if ch.isdigit()])

    # Compare letter and number portions to select the more relevant output
    if primary_letters == secondary_letters and primary_numbers == secondary_numbers:
        return primary_result  # Both are identical, so we can return either

    # If letters match, choose the one with matching numbers
    if primary_letters == secondary_letters:
        if primary_numbers == secondary_numbers:
            return primary_result  # If numbers are the same, choose primary
        else:
            return secondary_result  # Choose the secondary result if it has the correct numbers

    # Otherwise, return the result with the best match
    return primary_result if primary_numbers == secondary_numbers else secondary_result

# Example usage
image_path = 'b4.jpeg'  # Replace with your image file path
result = detect_and_recognize_plate(image_path)
print("Final Extracted License Plate Text:", result)